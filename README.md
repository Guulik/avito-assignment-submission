# Требования по утилитам

- Утилита GNU Make
- Docker
- 
# Инструкция по запуску


Чтобы запустить сервис, достаточно написать в корневой папке репозитория

```
make first-run
```

Эта команда соберет docker image со всеми зависимостями, запустит контейнер и проведет тесты. 
Во время тестов будет создано 200 случайных банеров

> Если у вас не прошёл какой-то тест, скорее всего вам просто не повезло.
> При генерации баннеров используются случайные значения uint32. Попробуйте запустить тесты ещё раз 
> с помощью```make test```

Если хотите сгенерировать больше банеров, используйте
```
make fake_banners
```

а вообще все команды описаны в Makefile

# Нагрузочное тестирование

запускаю вот с такими параметрами:
500 потоков константно и без задержек

![Параметры](assets/Pasted image 20240413211856.png)

### Первый тест

запрос на получение баннера с фичей 9 и тегом 1
<br><img src="assets/Pasted image 20240413131510.png" width="800" /><br>

при такой нагрузке отдельный запрос из postman на получение ВСЕХ баннеров занял 55 ms. Их там лежало порядка 700 штук
<br><img src="assets/Pasted image 20240413133219.png" width="800" /><br>

на создание 57 мс<br>
<br><img src="assets/Pasted image 20240413133111.png" width="800" /><br>

На получение баннера, который НЕ в начале базы лежит - 38 ms. Индексы хорошо отрабатывают :)
<br><img src="assets/Pasted image 20240413132956.png" width="800" /><br>

### Ещё итерация

Ещё запустил в 2 разных запроса. Здесь идёт обращение к 2 конкретным баннерам, соответственно они уже успели попасть в
кеш. RPS получается в районе 14к, среднее время ответа 31мс. В SLO уложился вроде :)
<br><img src="assets/Pasted image 20240413211654.png" width="800" /><br>

### Вариант более экстремальный

Попозже я решил проверить, что будет, если к 1000 пользователей, которым нужны баннеры, добавить ещё 100 неугомонных
админов, которые запускают процессы, чтобы смотреть содержимое всех баннеров. Здесь уже результаты не такие красивые -
среднее время ответа составило 200мс, но это при RPS=5к.
<br><img src="assets/Pasted image 20240413134530.png" width="800" /><br>

В постмане та же история
<br><img src="assets/Pasted image 20240413134822.png" width="800" /><br>

Потом попробовал разное количство потоков и пришёл к RPS=1к, как в задани
При такой нагрузке время ответа на получение конкретного баннера составляет чуть меньше 50мс, как и требовалось в
условии
<br><img src="assets/Pasted image 20240413140156.png" width="800" /><br>

за всё время пока тестил на сервер пришло 33гб а отдал он 61гб.
<br><img src="assets/Pasted image 20240413141032.png" width="800" /><br>
Эмулировать создание и обновление баннеров через Jmeter я не стал, поскольку это довольно трудозатратно в плане
написания генератора, да и я не знаю как, если честно. Решил оставшееся время потратить на более важные вещи)
## Выводы
Вроде сервер неплохо себя показывает:) Также надо ещё по-хорошему эмулировать создание, обновление и удаление баннеров.
Тут ещё стоит сделать ВАЖНОЕ замечание, что запускается это всё дело через докер, но на моей локальной машине, которая довольно ограничена в русурсах. Ноут у меня не очень мощный - CPU:Ryzen 5 4600  RAM: 16GB (из которых обычно свободно не больше 10 GB). Скорее всего на настоящем сервере будет работать быстрее. Не проверял :)

# Удаление по фиче или тегу
у меня в базе сейчас примерно 500 баннеров (пока тестил удаление, id дошёл до 3200, так что первая запись имеет id
3211). У них у всех фича стоит 777, чтобы протестить удаление большого количества баннеров
<br><img src="assets/Pasted image 20240413204839.png" width="800" /><br>

если попытаться удалить все баннеры с фичей 777(почти 500 штук), то время ответа составит <100ms.
<br><img src="assets/Pasted image 20240413204922.png" width="800" /><br>
Но это без нагрузки

А вот с нагрузкой. 12к RPS (к кешированным баннерам). Время ответа на Delete по фиче = 27ms.
<br><img src="assets/Pasted image 20240413204922.png" width="800" /><br>

В Delete у меня реализовано выполнение отложенного действия через defer, так что по сути вся работа по удалению
происходит после ответа клиенту. Не знаю, такая ли реализация имелась в виду в дополнительном задании,
но я реализовал так.


